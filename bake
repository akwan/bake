#!/usr/bin/env bash
set -Eeu

# TODO: detect if we're being sourced or if we're being executed
BAKE_VERSION="2014-11-05"
BAKE_STDOUT_IS_TERMINAL=""
BAKE_COLOR_NORMAL=""
BAKE_COLOR_RED=""
BAKE_COLOR_LRED=""
BAKE_COLOR_BLUE=""
BAKE_COLOR_LBLUE=""
BAKE_COLOR_GREEN=""
BAKE_COLOR_LGREEN=""
BAKE_URL="https://raw.githubusercontent.com/kyleburton/bake/master/bake"

BAKE_LOG_LEVEL_NONE=0  # none
BAKE_LOG_LEVEL_FATAL=1 # fatal
BAKE_LOG_LEVEL_ERROR=2 # error
BAKE_LOG_LEVEL_WARN=3  # warn
BAKE_LOG_LEVEL_INFO=4  # info
BAKE_LOG_LEVEL_DEBUG=5 # debug
BAKE_LOG_LEVEL="${BAKE_LOG_LEVEL:-$BAKE_LOG_LEVEL_INFO}"

# BAKEPATH
#
#  The list of directories that bake will search when resolving libraries (via require)
#
BAKEPATH="${BAKEPATH:-.}"

BAKE_DEFAULT_TASK=""
declare -A BAKE_TASKS
declare -A BAKE_TASK_DESCRIPTIONS
declare -A BAKE_LIBS

function bake_push_libdir () {
  local path="$1"
  export BAKEPATH="$path:$BAKEPATH"
}

function bake_add_libdir () {
  local path="$1"
  export BAKEPATH="$BAKEPATH:$path"
}

function bake_default_task () {
  local task="$1"
  export BAKE_DEFAULT_TASK="$task"
}

function bake_root_dir () {
  # see: http://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
  pushd $(dirname $0) > /dev/null
  local BAKE_ROOT_DIR="$(pwd)"
  popd > /dev/null
  echo "$BAKE_ROOT_DIR"
}

function bake_bakefile_dir () {
  dirname $BAKEFILE
}

BAKE_ROOT_DIR="$(bake_root_dir)"

# sources a library
function bake_require () {
  local file="$1"
  for path in $(echo "$BAKEPATH" | tr : ' '); do
    local fname="$path/$file"
    if [ -e "$fname" ]; then
      BAKE_LIBS["$file"]="$fname"
      source $fname
      return 0
    fi

    fname="$path/$file.sh"
    if [ -e "$fname" ]; then
      BAKE_LIBS["$file"]="$fname"
      source $fname
      return 0
    fi
  done

  echo "Error: unable to require $file! (not found on BAKEPATH)"
  return 1
}

function bake_require_all () {
  local path="$1"
  for f in $(find "$path" -type f); do
    bake_require $f
  done
}

function bake_task () {
  local name="${1:-}"
  local short_desc="${2:-No Description for task: $name}"
  if [ -z "$name" ]; then
    echo "Error: you must supply a task name!"
    return 1
  fi
  BAKE_TASKS[$name]="ok"
  BAKE_TASK_DESCRIPTIONS[$name]="$short_desc"
}

function bake_task_short_desc () {
  local name="${1:-}"
  echo "${BAKE_TASK_DESCRIPTIONS[$name]}" | head -n 1
}

function bake_is_registered_task () {
  local name="$1"
  local value="${BAKE_TASKS[$name]:-}"
  test "$value" = "ok"
}

function bake_cd () {
  local path="${1:-}"
  if [ -z "$path" ]; then
    cd $(dirname $BAKEFILE)
  else
    cd $(dirname $BAKEFILE)/$path
  fi
}

function bake_find_bakefile_impl () {
  local project_root="$(pwd)"

  if [ -e "Bakefile" ]; then
    echo "$project_root/Bakefile"
    return 0
  fi

  if [ -e "bakefile" ]; then
    echo "$project_root/bakefile"
    return 0
  fi

  if [ "/" = "$(pwd)" ]; then
    echo ""
    return 1;
  fi

  cd ..
  bake_find_bakefile_impl
}

function bake_find_bakefile () {
  local start_path="$(pwd)"
  if [ -n "${BAKEFILE:-}" ]; then
    echo "$BAKEFILE"
    return 0
  fi

  bake_find_bakefile_impl
  cd "$start_path" > /dev/null 2>&1
}

function bake_inernal_help () {
  echo "$0 task [arg ...]"
  echo ""
  echo "Tasks are taken from the file Bakefile (or bakefile) in the $PWD."
  echo "You can specify an alternate Bakefile by setting BAKEFILE:"
  echo ""
  echo "  BAKEFILE=\"my.Bakefile\" bake"
  echo ""
}

function bake_sorted_task_list () {
  for task in "${!BAKE_TASKS[@]}"; do
    echo $task
  done | sort
}

function bake_show_matching_tasks () {
  local unknown_task="${1:-}"
  local matches=""
  #for task in "${!BAKE_TASKS[@]}"; do
  for task in $(bake_sorted_task_list); do
    if [[ "$task" == *$unknown_task* ]]; then
      matches="$matches $task"
      printf "  %-30s %s\n" "$task" "$(bake_task_short_desc $task)"
    fi
  done

  if [ -z "$matches" ]; then
    return 1
  else
    return 0
  fi
}

function bake_show_all_tasks () {
  for task in $(bake_sorted_task_list); do
    printf "  %-30s %s\n" "$task" "$(bake_task_short_desc $task)"
  done
}

function bake_bakefile_help () {
  local unknown_task="${1:-}"
  echo ""
  echo "$0 task [arg ...]"
  echo ""
  if [ -n "$unknown_task" ]; then
    if ! bake_show_matching_tasks "$unknown_task"; then
      bake_show_all_tasks
    fi
  else
    bake_show_all_tasks
  fi

  echo ""
}

function bake_upgrade () {
  curl -o $0 "$BAKE_URL"
  chmod 755 $0
}

function bake_run () {
  local task="${1:-}"
  if [ -n "$task" ]; then
    shift
  fi

  local args="$@"
  local bakefile="$(bake_find_bakefile)"

  if [ ! -e "$bakefile" ]; then
    if [ "$task" == upgrade ]; then
      bake_upgrade
      return 0
    fi

    echo "Error: could not locate a Bakefile!"
    echo ""
    bake_inernal_help
    return 1
  fi

  export BAKEFILE="$bakefile"

  source $bakefile

  if [ -n "$task" ]; then
    if bake_is_registered_task "$task"; then
      $task "$@"
      exit $?
    fi
  fi

  if [ -n "$BAKE_DEFAULT_TASK" ]; then
    "$BAKE_DEFAULT_TASK"
    exit $?
  fi

  if [ "$task" == upgrade ]; then
    bake_upgrade
    return 0
  fi

  bake_bakefile_help "$task"
  exit 1
}

# detect if we're being run or sourced
# from: http://stackoverflow.com/questions/2683279/how-to-detect-if-a-script-is-being-sourced
function bake_is_main () {
  test "${FUNCNAME[1]}" = "main"
}

function bake_init () {
  if [ -t 1 ]; then
    BAKE_STDOUT_IS_TERMINAL="yes"
    BAKE_COLOR_NORMAL="\e[00m"
    BAKE_COLOR_RED="\e[00;31m"
    BAKE_COLOR_LRED="\e[01;31m"
    BAKE_COLOR_BLUE="\e[00;34m"
    BAKE_COLOR_LBLUE="\e[01;34m"
    BAKE_COLOR_GREEN="\e[00;32m"
    BAKE_COLOR_LGREEN="\e[01;32m"
  fi
}

function bake_echo_red () {
  echo -e "${BAKE_COLOR_RED}$@${BAKE_COLOR_NORMAL}"
}

function bake_echo_blue () {
  echo -e "${BAKE_COLOR_BLUE}$@${BAKE_COLOR_NORMAL}"
}

function bake_echo_green () {
  echo -e "${BAKE_COLOR_GREEN}$@${BAKE_COLOR_NORMAL}"
}

function bake_log_debug () {
  if [ $BAKE_LOG_LEVEL -ge $BAKE_LOG_LEVEL_DEBUG ]; then
    echo "[DEBUG ${FUNCNAME[1]}] $@"
  fi
}

function bake_log_info () {
  if [ $BAKE_LOG_LEVEL -ge $BAKE_LOG_LEVEL_INFO ]; then
    echo "[INFO ${FUNCNAME[1]}] $@"
  fi
}

function bake_log_warn () {
  if [ $BAKE_LOG_LEVEL -ge $BAKE_LOG_LEVEL_WARN ]; then
    echo "[WARN ${FUNCNAME[1]}] $@"
  fi
}

function bake_log_error () {
  if [ $BAKE_LOG_LEVEL -ge $BAKE_LOG_LEVEL_ERROR ]; then
    echo "[ERROR ${FUNCNAME[1]}] $@"
  fi
}

function bake_log_fatal () {
  if [ $BAKE_LOG_LEVEL -ge $BAKE_LOG_LEVEL_FATAL ]; then
    echo "[FATAL ${FUNCNAME[1]}] $@"
  fi
}

function bake_log_level () {
  local level="$1"
  case "$level" in
    debug)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_DEBUG"
      ;;
    info)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_INFO"
      ;;
    warn)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_WARN"
      ;;
    error)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_ERROR"
      ;;
    fatal)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_FATAL"
      ;;
    none)
      export BAKE_LOG_LEVEL="$BAKE_LOG_LEVEL_NONE"
      ;;
  esac
}

bake_init

if bake_is_main; then
  bake_run "$@"
fi
